/*-------------------------------------------------------------------------
CMM Compiler description for C--
=== ============================
-------------------------------------------------------------------------*/

COMPILER CMM

  public  KempTable       tab;                     // symbol table
  public  boolean[] debug = new boolean[10]; // switches for trace output

//--- LL(1) conflict resolvers

	// Returns true if a VarDecl comes next in the input
	boolean isVarDecl() {
		if (la.kind == _ident) {
			Token x = scanner.Peek();
			while (x.kind != _semicolon) {
				if (x.kind == _EOF || x.kind == _lpar || x.kind == _assign) return false;
				x = scanner.Peek();
			}
			return true;
		}
		return false;
	}

	// Returns true if the next input is an Expr and not a '(' Condition ')'
	boolean isExpr() {
		if (la.kind == _bang) return false;
		else if (la.kind == _lpar) {
			Token x = scanner.Peek();
			while (x.kind != _rpar && x.kind != _EOF) {
				if (x.kind == _eql || x.kind == _neq || x.kind == _lss || x.kind == _leq || x.kind == _gtr || x.kind == _geq) return false;
				x = scanner.Peek();
			}
			return x.kind == _rpar;
		} else return true;
	}

	// Returns true if the next input is a type cast (requires symbol table)
	boolean isCast() {
		Token x = scanner.Peek();
		if (x.kind != _ident)
		    return false;

        try{
            KempType.valueOf(x.val.toUpperCase());
            return true;
        }catch (IllegalArgumentException e){
            return false;
        }
	}

    String readCurrent(){
        return this.la.val;
    }

    String read1Ahead(){
        scanner.ResetPeek();
        return scanner.Peek().val;
    }

	String read2Ahead(){
        scanner.ResetPeek();
        scanner.Peek();
        return scanner.Peek().val;
    }

    String read3Ahead(){
        scanner.ResetPeek();
        scanner.Peek();
        scanner.Peek();
        return scanner.Peek().val;
    }

    String read4Ahead(){
        scanner.ResetPeek();
        scanner.Peek();
        scanner.Peek();
        scanner.Peek();
        return scanner.Peek().val;
    }

    void printNext5Values(){
        scanner.ResetPeek();
        System.out.println("Current Token Value: "+this.la.val);
        for(int i = 0; i < 4; i++) {
	        System.out.println("Value: "+scanner.Peek().val);
        }
     }

//    tab.addNode(type,name,value,kind);


    void variableDecleration(){
        System.out.println("---------");
        System.out.println("Variable declaration");
//        readNext5Values();
        tab.addNode(readCurrent(),read1Ahead(),null,KempKind.VARIABLE);
        System.out.println("---------");
    }

    void constantDecleration(){
        System.out.println("---------");
        System.out.println("Constant declaration");
//        readNext5Values();
        tab.addNode(read1Ahead(),read2Ahead(),read4Ahead(),KempKind.CONSTANT);
        System.out.println("---------");
    }

    void procedureDecleration(){
        System.out.println("---------");
        System.out.println("Procedure declaration");
//        readNext5Values();
        tab.addNode(readCurrent(),read1Ahead(),null,KempKind.PROCEDURE);
        System.out.println("---------");
    }

    void structDecleration(){
        System.out.println("---------");
        System.out.println("Struct declaration");
//        readNext5Values();

        tab.addNode(KempType.STRUCT.name(),read1Ahead(),read4Ahead(),KempKind.STRUCT);
        System.out.println("---------");
    }

    void statementDecleration(){
        System.out.println("---------");
        System.out.println("Statement declaration");
        printNext5Values();
        System.out.println("---------");
    }

    void openScope(){
        System.out.println("Opening Scope");
        tab.openScope();
    }

    void closeScope(){
        System.out.println("Closing Scope");
        tab.openScope();
    }

/*-------------------------------------------------------------------------*/

CHARACTERS
  letter    = 'A'..'Z' + 'a'..'z'.
  digit     = '0'..'9'.
  charCh    = ANY - '\r' - '\n' - '\t' - '\'' - '\\'.

TOKENS
  ident     = letter { letter | digit }.
  intCon    = digit { digit }.
  floatCon  = digit {digit} '.' {digit} ['E' ['+'|'-'] digit {digit}].
  charCon   = '\'' ( charCh | '\\' ('r' | 'n' | 't' | '\'' | '\\' )) '\''.
  whitespace = '\t' | '\r' | '\n'.



  //--- token definitions for lookahead peeking
  lpar      = "(".
  rpar      = ")".
  semicolon = ";".
  assign    = '='.
  eql       = "==".
  neq       = "!=".
  lss       = "<".
  leq       = "<=".
  gtr       = ">".
  geq       = ">=".
  bang      = "!".

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO '\n'

IGNORE "\t\r\n"

//-------------------------------------------------------------------------

PRODUCTIONS

CMM
=	                                (. tab = new KempTable(); .)
{ ConstDecl
| StructDecl
| IF(isVarDecl()) VarDecl
| ProcDecl
}                                   (. tab.dumpTable(); .)
.
//-------------------------------------------------------------------------
ConstDecl
=                                   (. constantDecleration(); .)
"const" Type ident "=" (intCon | floatCon | charCon) ";".
//-------------------------------------------------------------------------
VarDecl
=                                   (. variableDecleration(); .)
Type ident {"," ident} ";".
//-------------------------------------------------------------------------
StructDecl                          (. structDecleration(); .)
=
"struct" ident "{"
                                    (. openScope(); .)
{ VarDecl}
                                    (. closeScope(); .)
"}".
//-------------------------------------------------------------------------
ProcDecl                            (. procedureDecleration(); .)
=
(Type | "void") ident "(" [ FormPars ] ")"
                                    (. openScope(); .)
"{"
{ ConstDecl
| IF(isVarDecl()) VarDecl
| Statement
}
"}"
                                    (. closeScope(); .)
| ";" "forward" ";".
//-------------------------------------------------------------------------
FormPars
=
FormPar {"," FormPar}.
//-------------------------------------------------------------------------
FormPar
=
["ref"] Type ident.
//-------------------------------------------------------------------------
Type
=
ident {"[" intCon "]"}.
//-------------------------------------------------------------------------
Statement
=                               (. statementDecleration(); .)
( Designator
  ( "=" Expr
  | ActPars
  ) ";"
| "if" "(" Condition ")" Statement ["else" Statement]
| "while" "(" Condition ")" Statement
| "print" "(" Expr ")" ";"
| "{"
                                    (. openScope(); .)
   {Statement}
                                    (. closeScope(); .)
   "}"
| "return" Expr ";"
| ";"
).
//-------------------------------------------------------------------------
ActPars
=
"(" [ActPar {"," ActPar}] ")".
//-------------------------------------------------------------------------
ActPar
=
Expr | "ref" Expr.
//-------------------------------------------------------------------------
Condition
=
CondTerm {"||" CondTerm}.
//-------------------------------------------------------------------------
CondTerm
=
CondFact {"&&" CondFact}.
//-------------------------------------------------------------------------
CondFact
=
( IF (isExpr()) Expr
  Relop
  Expr
| "!" "(" Condition ")"
| "(" Condition ")"
).
//-------------------------------------------------------------------------
Relop = "==" | "!=" | ">" | ">=" | "<" | "<=".
//-------------------------------------------------------------------------
Expr
=
Term {Addop Term}.
//-------------------------------------------------------------------------
Term
=
Factor {Mulop Factor}.
//-------------------------------------------------------------------------
Factor
=
( Designator [ActPars]
| intCon
| floatCon
| charCon
| "read" "(" ")"
| "-" Factor
| IF (isCast())
  "(" Type ")" Factor
| "(" Expr ")"
).
//-------------------------------------------------------------------------
Designator
=
ident {"." ident | "[" Expr "]"}.
//-------------------------------------------------------------------------
Addop
=
"+" | "-".
//-------------------------------------------------------------------------
Mulop
=
"*" | "/" | "%".

END CMM.