/*-------------------------------------------------------------------------
CMM Compiler description for C--
=== ============================
-------------------------------------------------------------------------*/

COMPILER CMM

    public  Tab     symbolTable;                     // symbol table


//--- LL(1) conflict resolvers

	// Returns true if a VarDecl comes next in the input
	boolean isVarDecl() {
		if (la.kind == _ident) {
			Token x = scanner.Peek();
			while (x.kind != _semicolon) {
				if (x.kind == _EOF || x.kind == _lpar || x.kind == _assign) return false;
				x = scanner.Peek();
			}
			return true;
		}
		return false;
	}

	// Returns true if the next input is an Expr and not a '(' Condition ')'
	boolean isExpr() {
		if (la.kind == _bang) return false;
		else if (la.kind == _lpar) {
			Token x = scanner.Peek();
			while (x.kind != _rpar && x.kind != _EOF) {
				if (x.kind == _eql || x.kind == _neq || x.kind == _lss || x.kind == _leq || x.kind == _gtr || x.kind == _geq) return false;
				x = scanner.Peek();
			}
			return x.kind == _rpar;
		} else return true;
	}

	// Returns true if the next input is a type cast
	boolean isCast() {
		Token x = scanner.Peek();
		if (x.kind != _ident)
		    return false;

        try{
            Type.valueOf(x.val.toUpperCase());
            return true;
        }catch (IllegalArgumentException e){
            return false;
        }
	}
/*-------------------------------------------------------------------------*/

CHARACTERS
  letter    = 'A'..'Z' + 'a'..'z'.
  digit     = '0'..'9'.
  charCh    = ANY - '\r' - '\n' - '\t' - '\'' - '\\'.

TOKENS
  ident     = letter { letter | digit }.
  intCon    = digit { digit }.
  floatCon  = digit {digit} '.' {digit} ['E' ['+'|'-'] digit {digit}].
  charCon   = '\'' ( charCh | '\\' ('r' | 'n' | 't' | '\'' | '\\' )) '\''.
  whitespace = '\t' | '\r' | '\n'.



  //--- token definitions for lookahead peeking
  lpar      = "(".
  rpar      = ")".
  semicolon = ";".
  assign    = '='.
  eql       = "==".
  neq       = "!=".
  lss       = "<".
  leq       = "<=".
  gtr       = ">".
  geq       = ">=".
  bang      = "!".
  mul       = "*".
  div       = "/".
  add       = "+".
  substr    = "-".

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO '\n'

IGNORE "\t\r\n"

//-------------------------------------------------------------------------

PRODUCTIONS

CMM
=	                                            (. symbolTable = new Tab(this);.)
{ ConstDecl
//| IF(isVarDecl()) VarDecl
| ProcDecl<out Obj procedure>                 (. symbolTable.insert(procedure);.)
}                                               (. symbolTable.dumpTable();.)
.



Ident<out String name>
=
ident (.name=this.t.val;.).
//-------------------------------------------------------------------------
ConstDecl
=
"const" Type<out Type type> Ident<out String name> "=" (intCon | floatCon | charCon)(.symbolTable.insert(ObjKind.CON,name,type);.) ";".
//-------------------------------------------------------------------------
VarDecl
=
Type<out Type type>
Ident<out String name> (.symbolTable.insert(ObjKind.VAR,name,type);.)
{"," Ident<out String name1> (.symbolTable.insert(ObjKind.VAR,name1,type);.)}
";".
//-------------------------------------------------------------------------
Type<out Type typ>
=
Ident<out String name>
(.
try {
    typ = Type.valueOf(name.toUpperCase());
} catch (IllegalArgumentException e) {
    throw new RuntimeException(e);
}
.)
.

ProcDecl<out Obj procedure>             (.NodeList nodeList=new NodeList();.)
=
Type<out Type type>
Ident<out String name>                  (.procedure=new Obj(ObjKind.PROC,name,type);symbolTable.openScope(procedure); int startLine=scanner.line;.)
"("
[
    Parameter<out Obj param1> (. symbolTable.insert(param1);.)
    {
        ',' Parameter<out Obj paramN>(. symbolTable.insert(paramN);.)
    }
]
")""{"
{
IF(isVarDecl())VarDecl
|Statement<out Node statement>          (.nodeList.add(statement);.)
}
(.procedure.ast=new Node(NodeKind.STATSEQ,nodeList.head,new Node(NodeKind.TRAP,null,null,scanner.line),startLine);symbolTable.closeScope();.)
"}"
.


Parameter<out Obj obj>
=
Type<out Type type> Ident<out String name>      (.obj=new Obj(ObjKind.VAR,name,type);.).
//-------------------------------------------------------------------------
Statement<out Node statement>                   (. statement=null; NodeList innerStatements=new NodeList();.)
=
(
Ident<out String name>
"=" Expr<out Node expression>                   (. statement=new Node(NodeKind.ASSIGN,new Node(symbolTable.find(name)),expression,scanner.line);/*Node.dump(expression,0);*/.)";"
| ReturnStatement<out Node retstat>             (.statement=retstat;.)
| ";"
| "print" "(" Expr<out Node expression> ")" ";" (. Node.dump(expression,0);.)
| "while""("Condition<out Node condition>")" Statement<out Node innerStatement>(.statement=new Node(NodeKind.WHILE,condition,innerStatement,scanner.line);.)
| "if""("Condition<out Node condition>")" Statement<out Node innerStatement>(.statement=new Node(NodeKind.IF,condition,innerStatement,scanner.line);.)
| "{"
{Statement<out Node innerStatement>             (. innerStatements.add(innerStatement); .)
}                                               (. statement=innerStatements.get(); .)
"}"
).


ReturnStatement<out Node statement>             (.statement=null; Node expression=null;.)
=
"return" [Expr<out expression>]                 (. statement=new Node(NodeKind.RETURN,expression,null,scanner.line);.)";".

//-------------------------------------------------------------------------
Expr<out Node expr>                             (.Node term;NodeKind kind;.)
=
Term<out expr>
{
Addop<out kind>
Term<out term>                                  (. expr=new Node(kind,expr,term,term.type==expr.type?term.type:null);.)
}
.
//-------------------------------------------------------------------------
Term<out Node term>                             (.Node faktor;NodeKind kind;.)
=
Factor<out term>
{
Mulop<out kind>
Factor<out faktor>                              (. term=new Node(kind,term,faktor,faktor.type==term.type?faktor.type:null); .)
}
.
//-------------------------------------------------------------------------
Factor <out Node faktor>        (.faktor=null;String name;.)
=
(
Ident<out name>                 (. faktor=new Node(symbolTable.find(name));.)
| intCon                        (. faktor=new Node(symbolTable.intVal(this.t.val)); .)
| floatCon                      (. faktor=new Node(symbolTable.floatVal(this.t.val)); .)
| charCon                       (. faktor=new Node(symbolTable.charVal(this.t.val)); .)
).
//-------------------------------------------------------------------------
//-------------------------------------------------------------------------
Addop<out NodeKind kind>        (.kind=null;.)
=
"+"                             (. kind=NodeKind.PLUS;.)
| "-"                           (.kind=NodeKind.MINUS; .).
//-------------------------------------------------------------------------
Mulop<out NodeKind kind>        (.kind=null;.)
=
"*"                             (.kind=NodeKind.TIMES;.)
| "/"                           (.kind=NodeKind.DIV;.)
| "%"                           (.kind=NodeKind.REM;.).





//-------------------------------------------------------------------------
//Boolean Operation
//-------------------------------------------------------------------------
Condition<out Node cond>
=
CondTerm<out cond>
{"||" CondTerm<out Node cond2> (.cond=new Node(NodeKind.OR,cond,cond2,Type.BOOL); .)}.
//-------------------------------------------------------------------------
CondTerm<out Node cond>
=
CondFact<out cond>
{"&&" CondFact<out Node cond2> (.cond=new Node(NodeKind.AND,cond,cond2,Type.BOOL); .)}.
//-------------------------------------------------------------------------
CondFact<out Node cond>         (.cond=null;.)
=
( IF (isExpr()) Expr<out Node expr1>
  Relop<out NodeKind which>
  Expr<out Node expr2>                      (.cond=new Node(which,expr1,expr2,Type.BOOL); .)
| "!" "(" Condition<out Node cond1> ")"   (. cond=new Node(NodeKind.NOT,cond1,null,Type.BOOL);.)
| "(" Condition<out Node cond1> ")"       (.cond=cond1;.)
).
//-------------------------------------------------------------------------
Relop<out NodeKind which>                   (.which=null;.)
=
("==" | "!=" | ">" | ">=" | "<" | "<=") (.which=NodeKind.get(t.kind);.).
//-------------------------------------------------------------------------


END CMM.




//-------------------------------------------------------------------------
