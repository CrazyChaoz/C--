/*-------------------------------------------------------------------------
CMM Compiler description for C--
=== ============================
-------------------------------------------------------------------------*/

COMPILER CMM

    public  SymbolTable     symbolTable;                     // symbol table
    public  SyntaxTree      globalTree;                      // syntax tree
    public  SyntaxTree      currentTree;                     // current syntax tree


    private SyntaxTree procedureTree;
//--- LL(1) conflict resolvers

	// Returns true if a VarDecl comes next in the input
	boolean isVarDecl() {
		if (la.kind == _ident) {
			Token x = scanner.Peek();
			while (x.kind != _semicolon) {
				if (x.kind == _EOF || x.kind == _lpar || x.kind == _assign) return false;
				x = scanner.Peek();
			}
			return true;
		}
		return false;
	}

	// Returns true if the next input is an Expr and not a '(' Condition ')'
	boolean isExpr() {
		if (la.kind == _bang) return false;
		else if (la.kind == _lpar) {
			Token x = scanner.Peek();
			while (x.kind != _rpar && x.kind != _EOF) {
				if (x.kind == _eql || x.kind == _neq || x.kind == _lss || x.kind == _leq || x.kind == _gtr || x.kind == _geq) return false;
				x = scanner.Peek();
			}
			return x.kind == _rpar;
		} else return true;
	}

	// Returns true if the next input is a type cast (requires symbol table)
	boolean isCast() {
		Token x = scanner.Peek();
		if (x.kind != _ident)
		    return false;

        try{
            Type.valueOf(x.val.toUpperCase());
            return true;
        }catch (IllegalArgumentException e){
            return false;
        }
	}


	//###### personal implementation

    String readCurrent(){
        return this.la.val;
    }

    String read1Ahead(){
        scanner.ResetPeek();
        return scanner.Peek().val;
    }

	String read2Ahead(){
        scanner.ResetPeek();
        scanner.Peek();
        return scanner.Peek().val;
    }

    String read3Ahead(){
        scanner.ResetPeek();
        scanner.Peek();
        scanner.Peek();
        return scanner.Peek().val;
    }

    String read4Ahead(){
        scanner.ResetPeek();
        scanner.Peek();
        scanner.Peek();
        scanner.Peek();
        return scanner.Peek().val;
    }

    void printNext5Values(){
        scanner.ResetPeek();
        System.out.println("Value: "+this.la.val);
        for(int i = 0; i < 4; i++) {
	        System.out.println("Value: "+scanner.Peek().val);
        }
     }

//    tab.addNode(type,name,value,kind);



    void variableDecleration(){
        symbolTable.addNode(read1Ahead(),read1Ahead(), readCurrent());
//        currentTree.addNode(Kind.IDENT);
//        currentTree.openScope();
//        currentTree.addNode(Kind.IDENT,readCurrent());
//        currentTree.closeScope();
    }

    void constantDecleration(){

        symbolTable.addNode(read2Ahead(),read4Ahead(),read1Ahead());

        currentTree.addNodeAndStepInto(Kind.CONSTANT);
        currentTree.addNode(Kind.IDENT,read2Ahead());
        currentTree.addNode(Kind.VALUE,read4Ahead());
        currentTree.stepOut();
    }

    void procedureDecleration(){

        SyntaxTree procTree=new SyntaxTree();

        SymbolNode symbolNode=new SymbolNode(read1Ahead(),procTree,readCurrent());

        currentTree.addNode(Kind.CALL,symbolNode);
        symbolTable.addNode(symbolNode);
        openProcedureTree(procTree);

    }

    void structDecleration(){
        symbolTable.addNode(Type.STRUCT.name(),read1Ahead(),read4Ahead());
    }

    void statementDecleration(){
        System.out.println("---------");
        System.out.println("Statement declaration");

        Token x=this.la;

        while (x.kind!=_semicolon){
            System.out.println("Value: "+x.val);
            x=scanner.Peek();
        }

        System.out.println("---------");
    }



    void openProcedureTree(SyntaxTree tree){
        currentTree=tree;
        currentTree.addNodeAndStepInto(Kind.STATSEQ);
    }

    void closeProcedureTree(){
        currentTree.addNode(Kind.TRAP);
        currentTree.stepOut();
        currentTree=globalTree;
    }


/*-------------------------------------------------------------------------*/

CHARACTERS
  letter    = 'A'..'Z' + 'a'..'z'.
  digit     = '0'..'9'.
  charCh    = ANY - '\r' - '\n' - '\t' - '\'' - '\\'.

TOKENS
  ident     = letter { letter | digit }.
  intCon    = digit { digit }.
  floatCon  = digit {digit} '.' {digit} ['E' ['+'|'-'] digit {digit}].
  charCon   = '\'' ( charCh | '\\' ('r' | 'n' | 't' | '\'' | '\\' )) '\''.
  whitespace = '\t' | '\r' | '\n'.



  //--- token definitions for lookahead peeking
  lpar      = "(".
  rpar      = ")".
  semicolon = ";".
  assign    = '='.
  eql       = "==".
  neq       = "!=".
  lss       = "<".
  leq       = "<=".
  gtr       = ">".
  geq       = ">=".
  bang      = "!".
  mul       = "*".
  div       = "/".
  add       = "+".
  substr    = "-".

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO '\n'

IGNORE "\t\r\n"

//-------------------------------------------------------------------------

PRODUCTIONS

CMM
=	                                (. symbolTable = new SymbolTable();globalTree=currentTree=new SyntaxTree(); .)
{ ConstDecl
| IF(isVarDecl()) VarDecl
| Assignment
}                                   (. symbolTable.dumpTable(); globalTree.dumpTree();.)
.



Ident<out String name>
=
ident (.name=this.t.val;.).
//-------------------------------------------------------------------------
ConstDecl
=                                   (. constantDecleration(); /*constant type setzen*/.)
"const" Type<out Type type> Ident<out String name> "=" (intCon | floatCon | charCon)(.currentTree.addNode(Kind.CONSTANT,(new SymbolNode(name,t.val,type)));.) ";".
//-------------------------------------------------------------------------
VarDecl
=                                   (. variableDecleration(); .)
Type<out Type type> ident {"," ident} ";".
//-------------------------------------------------------------------------
Type<out Type typ>
=
Ident<out String name>
(.
try {
    typ = Type.valueOf(name.toUpperCase());
} catch (IllegalArgumentException e) {
    throw new RuntimeException(e);
}
.)
.

Assignment
=
Statement<out SyntaxNode statement> (. currentTree.addNode(Kind.ASSIGN,statement);.).
//-------------------------------------------------------------------------
Statement<out SyntaxNode parentOperation>         (.parentOperation=new SyntaxNode(Kind.PARENT,Kind.PARENT);.)
=
( Ident<out String name>                    (. parentOperation.addChild(new SyntaxNode(name,Kind.IDENT));.)
   "=" Expr<out SyntaxNode expression>      (. parentOperation.addChild(expression);.)";"
| "return" Expr<out SyntaxNode expression>  (. SyntaxNode aReturn=new SyntaxNode("return",Kind.RETURN);aReturn.addChild(expression);parentOperation.addChild(aReturn);.)";"
| ";"
).
Expr<out SyntaxNode parentOperation>                 (.parentOperation=new SyntaxNode(Kind.PARENT,Kind.PARENT);.)
=
Term<out SyntaxNode term>                       (.parentOperation.addChild(term);.)
{
Addop<out Kind kind>                                 (. parentOperation.addChild(new SyntaxNode(null,kind)); .)
Term<out SyntaxNode term1>                       (. parentOperation.addChild(term1);.)
}
.
//-------------------------------------------------------------------------
Term<out SyntaxNode parentOperation>                       (.parentOperation=new SyntaxNode(Kind.PARENT,Kind.PARENT);.)
=
Factor<out SymbolNode faktor>                   (.parentOperation.addChild(faktor);.)
{
Mulop<out Kind kind>                                 (. parentOperation.addChild(new SyntaxNode(null,kind)); .)
Factor<out SymbolNode faktor1>                   (. parentOperation.addChild(faktor1); .)
}
.
//-------------------------------------------------------------------------
Factor <out SymbolNode faktor>  (.faktor=null;.)
=
(
intCon                      (. faktor=new SymbolNode("intVal",t.val,"INT"); .)
| floatCon                  (. faktor=new SymbolNode("floatVal",t.val,"FLOAT"); .)
| charCon                   (. faktor=new SymbolNode("charVal",t.val,"CHAR"); .)
).
//-------------------------------------------------------------------------
//-------------------------------------------------------------------------
Addop<out Kind kind>         (.kind=null;.)
=
"+"                         (. kind=Kind.PLUS;.)
| "-"                       (.kind=Kind.MINUS; .).
//-------------------------------------------------------------------------
Mulop<out Kind kind>        (.kind=null;.)
=
"*"                         (.kind=Kind.TIMES;.)
| "/"                       (.kind=Kind.DIV;.)
| "%"                       (.kind=Kind.REM;.).

END CMM.

//new SymbolNode(String name, Object value, String type);



//-------------------------------------------------------------------------

//-------------------------------------------------------------------------
//Condition<out boolean truefalse>
//=
//CondTerm<out boolean truefalse1> (.truefalse=truefalse1;.)
//{"||" CondTerm<out boolean truefalse2> (.truefalse=truefalse&&truefalse2;.)}.
////-------------------------------------------------------------------------
//CondTerm<out boolean truefalse>
//=
//CondFact<out boolean truefalse1>(.truefalse=truefalse1;.)
//{"&&" CondFact<out boolean truefalse2>(.truefalse=truefalse&&truefalse2;.) }.
////-------------------------------------------------------------------------
//CondFact<out boolean truefalse>
//=
//( IF (isExpr()) Expr<out SyntaxNode expr1>
//  Relop<out int which>
//  Expr<out SyntaxNode expr2>
//| "!" "(" Condition<out boolean cond> ")"   (.truefalse=!cond;.)
//| "(" Condition<out boolean cond> ")"       (.truefalse=cond;.)
//).
////-------------------------------------------------------------------------
//Relop<out int which> = "==" | "!=" | ">" | ">=" | "<" | "<=" (.which=t.kind;.).
//-------------------------------------------------------------------------